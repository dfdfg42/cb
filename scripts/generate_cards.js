#!/usr/bin/env node
const fs = require('fs');
const path = require('path');

function parseCSVLine(line) {
  const fields = [];
  let cur = '';
  let inQuotes = false;
  for (let i = 0; i < line.length; i++) {
    const ch = line[i];
    if (ch === '"') {
      if (inQuotes && line[i+1] === '"') { // escaped quote
        cur += '"';
        i++;
      } else {
        inQuotes = !inQuotes;
      }
    } else if (ch === ',' && !inQuotes) {
      fields.push(cur);
      cur = '';
    } else {
      cur += ch;
    }
  }
  fields.push(cur);
  return fields.map(f => f === '' ? '' : f.trim());
}

function parseCSV(content) {
  const lines = content.split(/\r?\n/);
  let header = null;
  const cards = [];
  for (let rawLine of lines) {
    const line = rawLine.trim();
    if (!line) continue; // skip empty
    // skip lines that are only commas
    if (/^,+$/.test(line)) continue;

    let cols = parseCSVLine(line);

    if (!header) {
      // first header line should contain 'id' as first column
      if (cols[0] && cols[0].toLowerCase() === 'id') {
        header = cols.map(h => (h||'').trim());
        continue;
      } else {
        // ignore any prologue until header found
        continue;
      }
    }

    // if a repeated header appears, skip it
    if (cols[0] && cols[0].toLowerCase() === 'id') continue;

    // If columns count doesn't match header, try to auto-fix common cases:
    // - tooltip (header index 3) contains extra commas but wasn't quoted properly
    // - or trailing fields missing -> pad with nulls
    if (cols.length !== header.length) {
      const expected = header.length;
      // If too many columns, assume extra commas belonged to tooltip (index 3)
      if (cols.length > expected) {
        const head = cols.slice(0, 3);
        const tail = cols.slice(cols.length - (expected - 4));
        const tooltipParts = cols.slice(3, cols.length - tail.length);
        const tooltip = tooltipParts.join(',');
        cols = [...head, tooltip, ...tail];
      } else if (cols.length < expected) {
        // pad with empty strings for missing columns
        while (cols.length < expected) cols.push('');
      }
    }

    const obj = {};
    for (let i = 0; i < Math.min(header.length, cols.length); i++) {
      const key = header[i];
      if (!key) continue; // skip empty header columns
      obj[key] = cols[i] === '' ? null : cols[i];
    }

    // coerce some types
    ['phys_atk','mind_atk','mp_cost','chain_value'].forEach(k => {
      if (obj[k] != null && obj[k] !== '') {
        const n = Number(obj[k]);
        obj[k] = Number.isNaN(n) ? obj[k] : n;
      }
    });
    if (obj['chainable']) {
      const v = String(obj['chainable']).toUpperCase();
      obj['chainable'] = (v === 'TRUE' || v === '1');
    }

    cards.push(obj);
  }
  return cards;
}

function generateTS(cards) {
  const header = `// AUTO-GENERATED by scripts/generate_cards.js
// Do not edit directly.

export interface RawCard {
  id: string;
  name?: string;
  attribute?: string;
  tooltip?: string;
  phys_atk?: number | null;
  mind_atk?: number | null;
  mp_cost?: number | null;
  type?: string;
  tags?: string | null;
  chainable?: boolean | null;
  chain_value?: number | null;
  target?: string | null;
  [k: string]: any;
}

export const CARDS: RawCard[] = `;

  const body = JSON.stringify(cards, null, 2);
  return header + body + ' as RawCard[];\n\nexport default CARDS;\n';
}

function main() {
  const csvPath = path.join(__dirname, '..', 'card.csv');
  if (!fs.existsSync(csvPath)) {
    console.error('card.csv not found at', csvPath);
    process.exit(1);
  }
  const csv = fs.readFileSync(csvPath, 'utf8');
  const cards = parseCSV(csv);
  const out = generateTS(cards);
  const outPath = path.join(__dirname, '..', 'src', 'data', 'cards.generated.ts');
  fs.writeFileSync(outPath, out, 'utf8');
  console.log(`Wrote ${cards.length} cards to ${outPath}`);
}

main();
